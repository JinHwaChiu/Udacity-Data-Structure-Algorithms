# Recursion

## Basic

### [Recursion Introduction](https://github.com/ZacksAmber/Udacity-Data-Structure-Algorithms/blob/main/2/1-3/recursion/introduction.ipynb)

---

### [Factorial using recursion](https://github.com/ZacksAmber/Udacity-Data-Structure-Algorithms/blob/main/2/1-3/recursion/Factorial%20using%20recursion.ipynb)

---

### [Reversing a String](https://github.com/ZacksAmber/Udacity-Data-Structure-Algorithms/blob/main/2/1-3/recursion/Reversing%20a%20string.ipynb)

---

### [Palindrome](https://github.com/ZacksAmber/Udacity-Data-Structure-Algorithms/blob/main/2/1-3/recursion/Checking%20Palindrome.ipynb)

A **palindrome** is a word that is the reverse of itselfâ€”that is, it is the same word when read forwards and backwards.

For example:
*  "madam" is a palindrome
* "abba" is a palindrome
*  "cat" is not
*  "a" is a trivial case of a palindrome

The goal of this exercise is to use recursion to write a function `is_palindrome` that takes a string as input and checks whether that string is a palindrome. (Note that this problem can also be solved with a non-recursive solution, but that's not the point of this exercise.)

---

### [Add One](https://github.com/ZacksAmber/Udacity-Data-Structure-Algorithms/blob/main/2/1-3/recursion/Add-One-Again.ipynb)

---

## Advanced

### [List Permutation](https://github.com/ZacksAmber/Udacity-Data-Structure-Algorithms/blob/main/2/1-3/recursion/Permutation.ipynb)

<mark>Hard</mark>

---

### [String Permutation](https://github.com/ZacksAmber/Udacity-Data-Structure-Algorithms/blob/main/2/1-3/recursion/String-Permutations.ipynb)

<mark>Hard</mark>

<mark>Unfinished</mark>

---

### [Keypad Combinations](https://github.com/ZacksAmber/Udacity-Data-Structure-Algorithms/blob/main/2/1-3/recursion/Keypad%20Combinations.ipynb)

A keypad on a cellphone has alphabets for all numbers between 2 and 9, as shown in the figure below:

<img style="float: center;height:200px;" src="Keypad.png" alt="A cell phone keypad that has letters associated with each number 2 through 9"><br>

You can make different combinations of alphabets by pressing the numbers.

For example, if you press 23, the following combinations are possible:

`ad, ae, af, bd, be, bf, cd, ce, cf`

Note that because 2 is pressed before 3, the first letter is always an alphabet on the number 2.
Likewise, if the user types 32, the order would be

`da, db, dc, ea, eb, ec, fa, fb, fc`


Given an integer `num`, find out all the possible strings that can be made using digits of input `num`. 
Return these strings in a list. The order of strings in the list does not matter. However, as stated earlier, the order of letters in a particular string matters.

<mark>Hard</mark>

<mark>Unfinished</mark>

---

### [Deep Reverse](https://github.com/ZacksAmber/Udacity-Data-Structure-Algorithms/blob/main/2/1-3/recursion/Deep%20Reverse.ipynb)

Define a procedure, `deep_reverse`, that takes as input a list, and returns a new list that is the deep reverse of the input list.  
This means it reverses all the elements in the list, and if any of those elements are lists themselves, reverses all the elements in the inner list, all the way down. 

>Note: The procedure must not change the input list itself.

**Example**<br>
Input: `[1, 2, [3, 4, 5], 4, 5]`<br>
Output: `[5, 4, [5, 4, 3], 2, 1]`<br>

**Hint**<br>
1. Begin with a blank final list to be returned.
2. Traverse the given list in the reverse order.
 * If an item in the list is a list itself, call the same function.
 * Otheriwse, append the item to the final list.


---

### [Call stack](https://github.com/ZacksAmber/Udacity-Data-Structure-Algorithms/blob/main/2/1-3/recursion/Call%20stack.ipynb)

---

### [Recurrence Relations](https://github.com/ZacksAmber/Udacity-Data-Structure-Algorithms/blob/main/2/1-3/recursion/Recurrence%20Relations.ipynb)

Binary Search

---

### [Tower of Hanoi](https://github.com/ZacksAmber/Udacity-Data-Structure-Algorithms/blob/main/2/1-3/recursion/Tower-of-Hanoi.ipynb)

<mark>Hard</mark>

<mark>Unfinished</mark>

